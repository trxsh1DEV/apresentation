//using Microsoft.Win32;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.ServiceProcess;
using System.Threading;
using System.Threading.Tasks;
using SystemInfo;
using System.Configuration;
using System.Text.RegularExpressions;
using WebSocketSharp;
using Newtonsoft.Json;
using System.Security.Cryptography;

namespace InventoryWindowsService
{
    public partial class InventoryService : ServiceBase
    {
        private CancellationTokenSource _cts;
        private WebSocket _webSocket;
        private static readonly string serverUrl = $"ws://{ConfigurationManager.AppSettings["ServerIp"]}:{ConfigurationManager.AppSettings["ServerPort"]}";
        private const int RECONNECT_DELAY = 5000; // 5 seconds
        private const int HEARTBEAT_INTERVAL = 300000;
        //private const int CONNECTION_TIMEOUT = 90000;
        private Timer _heartbeatTimer;
        private DateTime _lastPongReceived;
        private int _failedPingCount = 0;
        private const int MAX_FAILED_PINGS = 5;
        private readonly object _reconnectLock = new object();
        private bool _isReconnecting = false;
        private string _uid;
        private string _companyCode;

        public InventoryService()
        {
            InitializeComponent();
        }

        protected override void OnStart(string[] args)
        {
            _cts = new CancellationTokenSource();

            // Initialize connection identifiers
            _uid = RegistryAccess.ReadFromRegistry("Identity") ??
                   RegistryAccess.WriteToRegistry(Guid.NewGuid().ToString(), "Identity");
            _companyCode = RegistryAccess.ReadFromRegistry("Company");

            if (string.IsNullOrEmpty(_uid) || string.IsNullOrEmpty(_companyCode))
            {
                throw new ArgumentException("UID or Company Code not found in registry.");
            }

            // Iniciar o serviço e o verificador de atualizações
            Task.Run(() => RunServiceAsync(_cts.Token), _cts.Token);
            Task.Run(() => StartCollectTask(_uid, _companyCode, _cts.Token), _cts.Token);
            Task.Run(() => CheckForUpdatesAsync(), _cts.Token);
        }

        private async Task CheckForUpdatesAsync()
        {
            try
            {
                await UpdateChecker.CheckAndScheduleUpdate(true);
            }
            catch (Exception ex)
            {
                EventLog.WriteEntry("InventoryService", $"Erro ao agendar atualização: {ex.Message}", EventLogEntryType.Error);
            }
        }

        protected override async void OnStop()
        {
            _cts?.Cancel();
            _heartbeatTimer?.Dispose();

            if (_webSocket != null && _webSocket.IsAlive)
            {
                _webSocket.Close();
            }

            await Task.Delay(5000);
        }

        private async Task RunServiceAsync(CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {

                    if (!_isReconnecting)
                    {
                        lock (_reconnectLock)
                        {
                            if (!_isReconnecting)
                            {
                                _isReconnecting = true;
                                InitializeWebSocket();
                            }
                        }
                    }

                    // Wait until cancellation is requested or connection is lost
                    while (!cancellationToken.IsCancellationRequested &&
                           _webSocket != null &&
                           _webSocket.IsAlive)
                    {
                        await Task.Delay(1000, cancellationToken);
                    }

                    // Reset reconnection flag if we've exited the loop
                    _isReconnecting = false;
                }
                catch (Exception ex)
                {
                    EventLog.WriteEntry("AgenteTrack", $"Connection Websocket error: {ex.Message}", EventLogEntryType.Error);
                    _isReconnecting = false;
                    await Task.Delay(RECONNECT_DELAY, cancellationToken);
                }
            }
        }

        private void InitializeWebSocket()
        {
            if (_webSocket != null)
            {
                _webSocket.Close();
                _webSocket = null;
            }

            _webSocket = new WebSocket(serverUrl);
            _lastPongReceived = DateTime.Now;

            _webSocket.OnOpen += async (sender, e) =>
            {
                try
                {
                    var identificationMessage = new
                    {
                        uid = _uid,
                        companyCode = _companyCode
                    };

                    var identificationMessageJson = JsonConvert.SerializeObject(identificationMessage);
                    _webSocket.Send(identificationMessageJson);
                    InitializeHeartbeatTimer();

                    EventLog.WriteEntry("AgenteTrack", "WebSocket connection established", EventLogEntryType.Information);
                }
                catch (Exception ex)
                {
                    EventLog.WriteEntry("AgenteTrack", $"Error in OnOpen Websocket: {ex.Message}", EventLogEntryType.Error);
                }
            };

            _webSocket.OnMessage += (sender, e) =>
            {
                try
                {
                    // Atualizar timestamp do último pong
                    if (e.Data == "pong")
                    {
                        _lastPongReceived = DateTime.Now;
                        //EventLog.WriteEntry("AgenteTrack", "Pong recebido do servidor", EventLogEntryType.Information);
                        return;
                    }

                    // Parse da resposta do servidor para confirmação de conexão
                    if (e.Data.Contains("status"))
                    {
                        var response = JsonConvert.DeserializeObject<dynamic>(e.Data);
                        if (response.status == "connected")
                        {
                            //EventLog.WriteEntry("AgenteTrack", "Connection confirmed by server", EventLogEntryType.Information);
                            return;
                        }
                    }

                    // Processar outros comandos...
                }
                catch (Exception ex)
                {
                    EventLog.WriteEntry("AgenteTrack", $"Error processing message: {ex.Message}", EventLogEntryType.Error);
                }
            };

            _webSocket.OnError += (sender, e) =>
            {
                EventLog.WriteEntry("AgenteTrack", $"WebSocket error: {e.Message}", EventLogEntryType.Error);
                InitiateReconnection();
            };

            _webSocket.OnClose += (sender, e) =>
            {
                // Só reconecta se não foi um fechamento intencional
                if (!_isReconnecting)
                {
                    //EventLog.WriteEntry("AgenteTrack", $"WebSocket connection closed unexpectedly. Code: {e.Code}, Reason: {e.Reason}", EventLogEntryType.Warning);
                    InitiateReconnection();
                }
            };

            try
            {
                _webSocket.Connect();
            }
            catch (Exception ex)
            {
                EventLog.WriteEntry("AgenteTrack", $"Connection failed Websocket: {ex.Message}", EventLogEntryType.Error);
                InitiateReconnection();
            }
        }
        private void InitializeHeartbeatTimer()
        {
            _heartbeatTimer?.Dispose();
            _heartbeatTimer = new Timer(async state =>
            {
                try
                {
                    if (_webSocket != null && _webSocket.IsAlive)
                    {
                        // Enviar ping para o servidor
                        _webSocket.Send("ping");

                        // Verificar se o último pong foi recebido dentro do intervalo aceitável
                        if ((DateTime.Now - _lastPongReceived).TotalMilliseconds > HEARTBEAT_INTERVAL)
                        {
                            _failedPingCount++;
                            //EventLog.WriteEntry("AgenteTrack", $"Falha no ping {_failedPingCount}", EventLogEntryType.Warning);
                            Utils.LogGeneric($"Falha no Ping ${_failedPingCount}", "connect_ws", "txt");

                            // Se falhar 5 vezes consecutivas, tenta reconectar
                            if (_failedPingCount >= MAX_FAILED_PINGS)
                            {
                                //EventLog.WriteEntry("AgenteTrack", "Máximo de falhas consecutivas de ping atingido. Tentando reconexão...", EventLogEntryType.Warning);
                                Utils.LogGeneric("Máximo de falhas consecutivas de ping atingido. Tentando reconexão...", "connect_ws", "txt");
                                _failedPingCount = 0;
                                Reconnect();
                            }
                        }
                        else
                        {
                            // Resetar contador se o pong for recebido dentro do tempo
                            _failedPingCount = 0;
                        }
                    }
                    else
                    {
                        //EventLog.WriteEntry("AgenteTrack", "WebSocket não está conectado. Tentando reconectar...", EventLogEntryType.Warning);
                        Utils.LogGeneric("WebSocket não está conectado. Tentando reconectar...", "connect_ws", "txt");
                        Reconnect();
                    }
                }
                catch (Exception ex)
                {
                    Utils.LogGeneric($"Erro no heartbeat: {ex.Message}", "connect_ws", "txt");
                    //EventLog.WriteEntry("AgenteTrack", $"Erro no heartbeat: {ex.Message}", EventLogEntryType.Error);
                }
            }, null, 0, HEARTBEAT_INTERVAL);
        }

        private void Reconnect()
        {
            lock (_reconnectLock)
            {
                if (!_isReconnecting)
                {
                    _isReconnecting = true;
                    _heartbeatTimer?.Dispose();

                    // Fechar a conexão existente e criar uma nova tentativa de conexão
                    if (_webSocket != null)
                    {
                        _webSocket.Close();
                        _webSocket = null;
                    }

                    // Esperar um tempo antes de tentar reconectar
                    Task.Delay(RECONNECT_DELAY).ContinueWith(_ =>
                    {
                        _isReconnecting = false;
                        InitializeWebSocket();
                    });
                }
            }
        }

        private void InitiateReconnection()
        {
            lock (_reconnectLock)
            {
                if (!_isReconnecting)
                {
                    _isReconnecting = true;
                    _heartbeatTimer?.Dispose();

                    Task.Run(async () =>
                    {
                        try
                        {
                            await Task.Delay(RECONNECT_DELAY);
                            InitializeWebSocket();
                        }
                        finally
                        {
                            _isReconnecting = false;
                        }
                    });
                }
            }
        }

        private async Task<string> ProcessCommand(string command)
        {
            var regex = new Regex(@"\bwinget ", RegexOptions.IgnoreCase | RegexOptions.Compiled);
            // Your existing command processing logic here

            // ...
            string result;
            if (regex.IsMatch(command))
            {
                result = await CommandShell.RunWingetFromConsoleApp(command, _uid, _companyCode);
            }
            else if (command.Length > 17 && command.Substring(0, 17) == "uninstall__winget")
            {
                result = await CommandShell.UninstallAppCommander(command.Substring(17), _uid, _companyCode);
            }
            //else if (command.Length >= 7 && command.Substring(0, 8) == "taskkill")
            //{
            //    result = await CommandShell.RunCommand(command);
            //}
            else
            {
                switch (command)
                {
                    case "shutdown_now":
                        Shutdown();
                        result = "Desligamento iniciado.";
                        break;
                    case "get_inventory":
                        await StartCollect(_uid, _companyCode);
                        result = "Coleta de inventário iniciada.";
                        break;
                    case "active_bitlocker":
                        ActiveBitlocker();
                        result = "Ativação do Bitlocker iniciada.";
                        break;
                    case "get_users_domain":
                        result = GetDomainUsers();
                        break;
                    //case "quit":
                    //    cts.Cancel();
                    //    result = "Encerrando conexão.";
                    //    break;
                    case "remove_agent":
                        result = await CommandShell.RunCommand(@"C:\Program Files\AgenteTrack\unins000.exe");
                        break;
                    default:
                        result = await CommandShell.RunCommand(command, _uid, _companyCode);
                        //Utils.LogGeneric(result, "commands_log", "txt");
                        break;
                }
            }
            return result;
        }

        //private void ConnectWebSocket()
        //{
        //    string uid = RegistryAccess.ReadFromRegistry("Identity") ??
        //                RegistryAccess.WriteToRegistry(Guid.NewGuid().ToString(), "Identity");
        //    string companyCode = RegistryAccess.ReadFromRegistry("Company");

        //    if (string.IsNullOrEmpty(uid))
        //        throw new ArgumentException("UID não encontrado no registro.");
        //    if (string.IsNullOrEmpty(companyCode))
        //        throw new ArgumentException("companyCode não encontrado no registro.");

        //    _webSocket = new WebSocket(serverUrl);

        //    // Configurar handlers
        //    _webSocket.OnOpen += async (sender, e) =>
        //    {
        //        var identificationMessage = new
        //        {
        //            uid,
        //            companyCode
        //        };

        //        // Verifique o JSON antes de enviar
        //        var identificationMessageJson = JsonConvert.SerializeObject(identificationMessage);
        //        _webSocket.Send(identificationMessageJson);

        //        // Iniciar coleta de inventário
        //        using var inventoryCts = new CancellationTokenSource();
        //        //var collectTask = StartCollectTask(uid, companyCode, inventoryCts.Token);

        //        // Configurar timer de ping
        //        _pingTimer = new Timer(_ =>
        //        {
        //            if (_webSocket.IsAlive)
        //            {
        //                _webSocket.Ping();
        //            }
        //        }, null, 0, PING_INTERVAL);
        //    };

        //    _webSocket.OnMessage += async (sender, e) =>
        //    {
        //        try
        //        {
        //            string command = e.Data;
        //            EventLog.WriteEntry("AgenteTrack", $"Comando recebido: {command}", EventLogEntryType.Warning);
        //            string result = "";

        //            // Aqui você coloca sua lógica de processamento de comandos
        //            // ... (mesmo código que você tinha antes para processar comandos)
        //            var regex = new Regex(@"\bwinget ", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        //            if (regex.IsMatch(command))
        //            {
        //                result = await CommandShell.RunWingetFromConsoleApp(command, uid, companyCode);
        //            }
        //            else if (command.Length > 17 && command.Substring(0, 17) == "uninstall__winget")
        //            {
        //                result = await CommandShell.UninstallAppCommander(command.Substring(17), uid, companyCode);
        //            }
        //            //else if (command.Length >= 7 && command.Substring(0, 8) == "taskkill")
        //            //{
        //            //    result = await CommandShell.RunCommand(command);
        //            //}
        //            else
        //            {
        //                switch (command)
        //                {
        //                    case "shutdown_now":
        //                        Shutdown();
        //                        result = "Desligamento iniciado.";
        //                        break;
        //                    case "get_inventory":
        //                        await StartCollect(uid, companyCode);
        //                        result = "Coleta de inventário iniciada.";
        //                        break;
        //                    case "active_bitlocker":
        //                        ActiveBitlocker();
        //                        result = "Ativação do Bitlocker iniciada.";
        //                        break;
        //                    case "get_users_domain":
        //                        result = GetDomainUsers();
        //                        break;
        //                    //case "quit":
        //                    //    cts.Cancel();
        //                    //    result = "Encerrando conexão.";
        //                    //    break;
        //                    case "remove_agent":
        //                        result = await CommandShell.RunCommand(@"C:\Program Files\AgenteTrack\unins000.exe");
        //                        break;
        //                    default:
        //                        result = await CommandShell.RunCommand(command, uid, companyCode);
        //                        //Utils.LogGeneric(result, "commands_log", "txt");
        //                        break;
        //                }
        //            }

        //            // Enviar resposta
        //            //EventLog.WriteEntry("AgenteTrack", $"Resultado comando: {command}", EventLogEntryType.Warning);
        //            if (!string.IsNullOrEmpty(result))
        //            {
        //                _webSocket.Send(result);
        //            }
        //        }
        //        catch (Exception ex)
        //        {
        //            EventLog.WriteEntry("AgenteTrack", $"Erro ao processar comando: {ex.Message}", EventLogEntryType.Error);
        //        }
        //    };

        //    _webSocket.OnError += (sender, e) =>
        //    {
        //        EventLog.WriteEntry("AgenteTrack", $"Erro WebSocket: {e.Message}", EventLogEntryType.Error);
        //    };

        //    _webSocket.OnClose += async (sender, e) =>
        //    {
        //        _pingTimer?.Dispose();
        //        if (!_cts.Token.IsCancellationRequested)
        //        {
        //            // Tentar reconectar após um delay
        //            await Task.Delay(RECONNECT_DELAY);
        //            ConnectWebSocket();
        //        }
        //    };

        //    // Conectar ao servidor
        //    _webSocket.Connect();
        //}
        static Task StartCollectTask(string uid, string companyCode, CancellationToken token)
        {
            return Task.Run(async () =>
            {
                Random random = new Random();
                int baseInterval = 4 * 60 * 60; // 4 horas em segundos
                int jitter = random.Next(0, 60 * 60 * 2); // Jitter de até 2 horas em segundos
                int interval = baseInterval + jitter;

                try
                {
                    // Coleta inicial
                    await StartCollect(uid, companyCode);

                    // Coleta periódica
                    while (!token.IsCancellationRequested)
                    {
                        await Task.Delay(interval * 1000, token);
                        await StartCollect(uid, companyCode);
                    }
                }
                catch (TaskCanceledException)
                {
                    // Tarefa cancelada, encerrar sem erros
                }
                catch (Exception ex)
                {
                    // Log de erro para acompanhar problemas na coleta periódica
                    EventLog.WriteEntry("InventoryService",$"Erro na coleta periódica: {ex.Message}", EventLogEntryType.Error);
                }
            });
        }

        static async Task StartCollect(string uid, string companyCode)
        {
            string FileName = "general_data.json";
            EventLog.WriteEntry("InventoryService", $"Coletando inventário para UID: {uid} e CompanyCode: {companyCode}", EventLogEntryType.Information);

            try
            {
                // Coleta de informações de inventário
                await Collector.InitializeIpInfoAsync();
                var processCollectorService = new ProcessCollectorService();
                var processesTask = processCollectorService.CollectProcessesAsync();
                var softwareTask = SoftwareCollector.GetInstalledSoftwareAsync();

                var generalInventoryTask = Task.Run(() => new Dictionary<string, object>
    {
        { "inventoryGeneral", new Dictionary<string, object>
            {
                { "cpu", Collector.CollectCpuInfo() },
                { "memory", Collector.CollectMemoryInfo() },
                { "system", Collector.GetSoInfo() },
                { "storage", Collector.GetDiskInfo() },
                { "users", new Dictionary<string, object>
                    {
                        { "users_can_login", Collector.UsersCanLogin() },
                        { "users_already_logged", Collector.GetLocalGroupUsers() }
                    }
                },
                { "motherboard", Collector.GetMotherboard() },
                { "network", Collector.GetNetworkInfo() },
                { "printers", Collector.GetInstalledPrinters() }
            }
        },
        { "location", Collector.Geolocation() },
        { "peripherals", Collector.GetDeviceInfo() },
        { "identifiers", Collector.CollectHardwareIdentifiers() },
        { "first_collect", Collector.CollectDataFirstCollect() },
        { "client", uid },
        { "companyCode", companyCode }
    });

                await Task.WhenAll(generalInventoryTask, softwareTask, processesTask);

                var generalInventory = await generalInventoryTask.ConfigureAwait(false);
                var processes = await processesTask.ConfigureAwait(false);
                var installedSoftware = await softwareTask.ConfigureAwait(false);

                var processInventory = new Dictionary<string, object>
    {
        { "processes", processes },
        { "host_ref", uid },
        { "companyCode", companyCode }
    };

                var softwareInventory = new Dictionary<string, object>
    {
        { "software", installedSoftware },
        { "host_ref", uid },
        { "companyCode", companyCode }
    };

                // Verifica dados anteriores
                var previousGeneralData = Utils.LoadJsonFromFile<Dictionary<string, object>>(FileName);
                if (previousGeneralData != null)
                {
                    var previousGeneralDataJObject = JObject.FromObject(previousGeneralData);

                    var requestBody = new
                    {
                        inventoryGeneral = generalInventory,
                        previousGeneralData = previousGeneralDataJObject,
                        uid,
                        companyCode
                    };

                    await HttpRequestHelper.SendPostRequestAsync("/inventory/general/history/test", requestBody)
                        .ConfigureAwait(false);
                }
                else
                {
                    var clientData = new Dictionary<string, object>
        {
            { "uid", uid },
            { "companyCode", companyCode }
        };
                    await HttpRequestHelper.SendPostRequestAsync("/clients", clientData).ConfigureAwait(false);
                }

                var tasks = new[]
                {
        HttpRequestHelper.SendPostRequestAsync("/inventory/general", generalInventory),
        HttpRequestHelper.SendPostRequestAsync("/software/inventory", softwareInventory),
        HttpRequestHelper.SendPostRequestAsync("/process/inventory", processInventory)
    };

                await Task.WhenAll(tasks).ConfigureAwait(false);
                Utils.SaveJsonToFile(generalInventory, FileName);

                    EventLog.WriteEntry("InventoryService", "Dados de inventário enviados com sucesso.", EventLogEntryType.Information);
                //}
                //else
                //{
                //    EventLog.WriteEntry("InventoryService", $"Arquivo {FileName} não encontrado no caminho Systempath.", EventLogEntryType.Warning);
                //}
            }
            catch (Exception ex)
            {
                EventLog.WriteEntry("InventoryService", $"Erro: {ex.Message}\nStackTrace: {ex.StackTrace}", EventLogEntryType.Error);
            }
        }
        static void Shutdown()
        {
            EventLog.WriteEntry("InventoryService", "Shutting down...", EventLogEntryType.Information);
            Process.Start("shutdown", "/s /t 0");
        }

        static void ActiveBitlocker()
        {
            EventLog.WriteEntry("InventoryService", "Activating Bitlocker...", EventLogEntryType.Information);
            // Implementar a ativação do Bitlocker
        }

        static string GetDomainUsers()
        {
            EventLog.WriteEntry("InventoryService", "Getting domain users...", EventLogEntryType.Information);
            // Implementar lógica de obtenção de usuários de domínio
            return "domain_user_1, domain_user_2";
        }

    }
}